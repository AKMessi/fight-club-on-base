"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/engine.ts":
/*!***********************!*\
  !*** ./lib/engine.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getResult: function() { return /* binding */ getResult; },\n/* harmony export */   mockOpponentConfig: function() { return /* binding */ mockOpponentConfig; },\n/* harmony export */   runBattleSimulation: function() { return /* binding */ runBattleSimulation; }\n/* harmony export */ });\n// --- Simulation Logic ---\n// Determines the market volatility seed based on the asset focus\nconst getMarketSeed = (focus)=>{\n    switch(focus){\n        case \"BlueChip\":\n            return 0.2; // Low Volatility\n        case \"Layer2\":\n            return 0.5; // Medium Volatility\n        case \"Memecoin\":\n            return 0.9; // High Volatility\n    }\n};\n// Generates a deterministic performance score (0 to 100)\n// Simplified logic: High risk pays off in high volatility (Memecoin), low risk pays off in low volatility (BlueChip)\nconst generatePerformanceScore = (config, marketSeed)=>{\n    // Normalize variables to 0-1\n    const riskNorm = config.riskLevel / 100;\n    const frequencyNorm = config.tradeFrequency / 100;\n    // Score calculation:\n    // 1. Base Score: A simple weighted average of risk and frequency (50/50 split)\n    let score = riskNorm * 0.5 + frequencyNorm * 0.5;\n    // 2. Volatility Alignment Bonus/Penalty:\n    //    - If Market Seed (volatility) is high (Memecoin), high risk gets a bonus.\n    //    - If Market Seed (volatility) is low (BlueChip), low risk gets a bonus.\n    const alignment = Math.abs(marketSeed - riskNorm);\n    // Apply a penalty based on misalignment (The smaller the alignment, the better the performance)\n    score = score + (1 - alignment) * 0.5;\n    // Scale the score back to 0-100 range and clamp\n    return Math.min(100, Math.max(0, Math.round(score * 100)));\n};\n// --- Battle Simulation Function ---\n// Returns a single number representing the final wealth score\nconst runBattleSimulation = (playerConfig)=>{\n    const marketSeed = getMarketSeed(playerConfig.assetFocus);\n    const score = generatePerformanceScore(playerConfig, marketSeed);\n    // Add a random element for drama, but keep it constrained (e.g., +/- 10%)\n    const randomFactor = Math.random() * 0.2 - 0.1; // -10% to +10%\n    const finalScore = score * (1 + randomFactor);\n    return Math.round(Math.min(100, Math.max(0, finalScore)));\n};\n// Simple mock opponent for comparison\nconst mockOpponentConfig = {\n    riskLevel: 45,\n    tradeFrequency: 55,\n    assetFocus: \"Layer2\"\n};\nconst getResult = (playerScore, opponentScore)=>{\n    if (playerScore > opponentScore + 10) return \"WIN\"; // Win by large margin\n    if (playerScore < opponentScore - 10) return \"LOSS\"; // Loss by large margin\n    return \"DRAW\"; // Close battle is a draw\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9lbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBVUEsMkJBQTJCO0FBRTNCLGlFQUFpRTtBQUNqRSxNQUFNQSxnQkFBZ0IsQ0FBQ0M7SUFDckIsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTyxLQUFLLGlCQUFpQjtRQUMvQixLQUFLO1lBQ0gsT0FBTyxLQUFLLG9CQUFvQjtRQUNsQyxLQUFLO1lBQ0gsT0FBTyxLQUFLLGtCQUFrQjtJQUNsQztBQUNGO0FBRUEseURBQXlEO0FBQ3pELHFIQUFxSDtBQUNySCxNQUFNQywyQkFBMkIsQ0FBQ0MsUUFBbUJDO0lBQ25ELDZCQUE2QjtJQUM3QixNQUFNQyxXQUFXRixPQUFPRyxTQUFTLEdBQUc7SUFDcEMsTUFBTUMsZ0JBQWdCSixPQUFPSyxjQUFjLEdBQUc7SUFFOUMscUJBQXFCO0lBQ3JCLCtFQUErRTtJQUMvRSxJQUFJQyxRQUFTSixXQUFXLE1BQU1FLGdCQUFnQjtJQUU5Qyx5Q0FBeUM7SUFDekMsK0VBQStFO0lBQy9FLDZFQUE2RTtJQUM3RSxNQUFNRyxZQUFZQyxLQUFLQyxHQUFHLENBQUNSLGFBQWFDO0lBRXhDLGdHQUFnRztJQUNoR0ksUUFBUUEsUUFBUSxDQUFDLElBQUlDLFNBQVEsSUFBSztJQUVsQyxnREFBZ0Q7SUFDaEQsT0FBT0MsS0FBS0UsR0FBRyxDQUFDLEtBQUtGLEtBQUtHLEdBQUcsQ0FBQyxHQUFHSCxLQUFLSSxLQUFLLENBQUNOLFFBQVE7QUFDdEQ7QUFFQSxxQ0FBcUM7QUFFckMsOERBQThEO0FBQ3ZELE1BQU1PLHNCQUFzQixDQUFDQztJQUNoQyxNQUFNYixhQUFhSixjQUFjaUIsYUFBYUMsVUFBVTtJQUN4RCxNQUFNVCxRQUFRUCx5QkFBeUJlLGNBQWNiO0lBRXJELDBFQUEwRTtJQUMxRSxNQUFNZSxlQUFlLEtBQU1DLE1BQU0sS0FBSyxNQUFPLEtBQUssZUFBZTtJQUNqRSxNQUFNQyxhQUFhWixRQUFTLEtBQUlVLFlBQVc7SUFFM0MsT0FBT1IsS0FBS0ksS0FBSyxDQUFDSixLQUFLRSxHQUFHLENBQUMsS0FBS0YsS0FBS0csR0FBRyxDQUFDLEdBQUdPO0FBQ2hELEVBQUU7QUFFRixzQ0FBc0M7QUFDL0IsTUFBTUMscUJBQWdDO0lBQ3pDaEIsV0FBVztJQUNYRSxnQkFBZ0I7SUFDaEJVLFlBQVk7QUFDaEIsRUFBRTtBQUVLLE1BQU1LLFlBQVksQ0FBQ0MsYUFBcUJDO0lBQzNDLElBQUlELGNBQWNDLGdCQUFnQixJQUFJLE9BQU8sT0FBTyxzQkFBc0I7SUFDMUUsSUFBSUQsY0FBY0MsZ0JBQWdCLElBQUksT0FBTyxRQUFRLHVCQUF1QjtJQUM1RSxPQUFPLFFBQVEseUJBQXlCO0FBQzVDLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2VuZ2luZS50cz9mMTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIEFzc2V0Rm9jdXMgPSBcIkJsdWVDaGlwXCIgfCBcIkxheWVyMlwiIHwgXCJNZW1lY29pblwiO1xyXG5cclxuZXhwb3J0IHR5cGUgQm90Q29uZmlnID0ge1xyXG4gIHJpc2tMZXZlbDogbnVtYmVyOyAvLyAxIHRvIDEwMFxyXG4gIHRyYWRlRnJlcXVlbmN5OiBudW1iZXI7IC8vIDEgdG8gMTAwXHJcbiAgYXNzZXRGb2N1czogQXNzZXRGb2N1cztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEJhdHRsZVJlc3VsdCA9IFwiV0lOXCIgfCBcIkxPU1NcIiB8IFwiRFJBV1wiO1xyXG5cclxuLy8gLS0tIFNpbXVsYXRpb24gTG9naWMgLS0tXHJcblxyXG4vLyBEZXRlcm1pbmVzIHRoZSBtYXJrZXQgdm9sYXRpbGl0eSBzZWVkIGJhc2VkIG9uIHRoZSBhc3NldCBmb2N1c1xyXG5jb25zdCBnZXRNYXJrZXRTZWVkID0gKGZvY3VzOiBBc3NldEZvY3VzKTogbnVtYmVyID0+IHtcclxuICBzd2l0Y2ggKGZvY3VzKSB7XHJcbiAgICBjYXNlIFwiQmx1ZUNoaXBcIjpcclxuICAgICAgcmV0dXJuIDAuMjsgLy8gTG93IFZvbGF0aWxpdHlcclxuICAgIGNhc2UgXCJMYXllcjJcIjpcclxuICAgICAgcmV0dXJuIDAuNTsgLy8gTWVkaXVtIFZvbGF0aWxpdHlcclxuICAgIGNhc2UgXCJNZW1lY29pblwiOlxyXG4gICAgICByZXR1cm4gMC45OyAvLyBIaWdoIFZvbGF0aWxpdHlcclxuICB9XHJcbn07XHJcblxyXG4vLyBHZW5lcmF0ZXMgYSBkZXRlcm1pbmlzdGljIHBlcmZvcm1hbmNlIHNjb3JlICgwIHRvIDEwMClcclxuLy8gU2ltcGxpZmllZCBsb2dpYzogSGlnaCByaXNrIHBheXMgb2ZmIGluIGhpZ2ggdm9sYXRpbGl0eSAoTWVtZWNvaW4pLCBsb3cgcmlzayBwYXlzIG9mZiBpbiBsb3cgdm9sYXRpbGl0eSAoQmx1ZUNoaXApXHJcbmNvbnN0IGdlbmVyYXRlUGVyZm9ybWFuY2VTY29yZSA9IChjb25maWc6IEJvdENvbmZpZywgbWFya2V0U2VlZDogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICAvLyBOb3JtYWxpemUgdmFyaWFibGVzIHRvIDAtMVxyXG4gIGNvbnN0IHJpc2tOb3JtID0gY29uZmlnLnJpc2tMZXZlbCAvIDEwMDtcclxuICBjb25zdCBmcmVxdWVuY3lOb3JtID0gY29uZmlnLnRyYWRlRnJlcXVlbmN5IC8gMTAwO1xyXG5cclxuICAvLyBTY29yZSBjYWxjdWxhdGlvbjpcclxuICAvLyAxLiBCYXNlIFNjb3JlOiBBIHNpbXBsZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHJpc2sgYW5kIGZyZXF1ZW5jeSAoNTAvNTAgc3BsaXQpXHJcbiAgbGV0IHNjb3JlID0gKHJpc2tOb3JtICogMC41ICsgZnJlcXVlbmN5Tm9ybSAqIDAuNSk7XHJcblxyXG4gIC8vIDIuIFZvbGF0aWxpdHkgQWxpZ25tZW50IEJvbnVzL1BlbmFsdHk6XHJcbiAgLy8gICAgLSBJZiBNYXJrZXQgU2VlZCAodm9sYXRpbGl0eSkgaXMgaGlnaCAoTWVtZWNvaW4pLCBoaWdoIHJpc2sgZ2V0cyBhIGJvbnVzLlxyXG4gIC8vICAgIC0gSWYgTWFya2V0IFNlZWQgKHZvbGF0aWxpdHkpIGlzIGxvdyAoQmx1ZUNoaXApLCBsb3cgcmlzayBnZXRzIGEgYm9udXMuXHJcbiAgY29uc3QgYWxpZ25tZW50ID0gTWF0aC5hYnMobWFya2V0U2VlZCAtIHJpc2tOb3JtKTtcclxuICBcclxuICAvLyBBcHBseSBhIHBlbmFsdHkgYmFzZWQgb24gbWlzYWxpZ25tZW50IChUaGUgc21hbGxlciB0aGUgYWxpZ25tZW50LCB0aGUgYmV0dGVyIHRoZSBwZXJmb3JtYW5jZSlcclxuICBzY29yZSA9IHNjb3JlICsgKDEgLSBhbGlnbm1lbnQpICogMC41OyBcclxuICBcclxuICAvLyBTY2FsZSB0aGUgc2NvcmUgYmFjayB0byAwLTEwMCByYW5nZSBhbmQgY2xhbXBcclxuICByZXR1cm4gTWF0aC5taW4oMTAwLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHNjb3JlICogMTAwKSkpO1xyXG59O1xyXG5cclxuLy8gLS0tIEJhdHRsZSBTaW11bGF0aW9uIEZ1bmN0aW9uIC0tLVxyXG5cclxuLy8gUmV0dXJucyBhIHNpbmdsZSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBmaW5hbCB3ZWFsdGggc2NvcmVcclxuZXhwb3J0IGNvbnN0IHJ1bkJhdHRsZVNpbXVsYXRpb24gPSAocGxheWVyQ29uZmlnOiBCb3RDb25maWcpOiBudW1iZXIgPT4ge1xyXG4gICAgY29uc3QgbWFya2V0U2VlZCA9IGdldE1hcmtldFNlZWQocGxheWVyQ29uZmlnLmFzc2V0Rm9jdXMpO1xyXG4gICAgY29uc3Qgc2NvcmUgPSBnZW5lcmF0ZVBlcmZvcm1hbmNlU2NvcmUocGxheWVyQ29uZmlnLCBtYXJrZXRTZWVkKTtcclxuXHJcbiAgICAvLyBBZGQgYSByYW5kb20gZWxlbWVudCBmb3IgZHJhbWEsIGJ1dCBrZWVwIGl0IGNvbnN0cmFpbmVkIChlLmcuLCArLy0gMTAlKVxyXG4gICAgY29uc3QgcmFuZG9tRmFjdG9yID0gKE1hdGgucmFuZG9tKCkgKiAwLjIpIC0gMC4xOyAvLyAtMTAlIHRvICsxMCVcclxuICAgIGNvbnN0IGZpbmFsU2NvcmUgPSBzY29yZSAqICgxICsgcmFuZG9tRmFjdG9yKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5taW4oMTAwLCBNYXRoLm1heCgwLCBmaW5hbFNjb3JlKSkpO1xyXG59O1xyXG5cclxuLy8gU2ltcGxlIG1vY2sgb3Bwb25lbnQgZm9yIGNvbXBhcmlzb25cclxuZXhwb3J0IGNvbnN0IG1vY2tPcHBvbmVudENvbmZpZzogQm90Q29uZmlnID0ge1xyXG4gICAgcmlza0xldmVsOiA0NSxcclxuICAgIHRyYWRlRnJlcXVlbmN5OiA1NSxcclxuICAgIGFzc2V0Rm9jdXM6IFwiTGF5ZXIyXCIsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UmVzdWx0ID0gKHBsYXllclNjb3JlOiBudW1iZXIsIG9wcG9uZW50U2NvcmU6IG51bWJlcik6IEJhdHRsZVJlc3VsdCA9PiB7XHJcbiAgICBpZiAocGxheWVyU2NvcmUgPiBvcHBvbmVudFNjb3JlICsgMTApIHJldHVybiBcIldJTlwiOyAvLyBXaW4gYnkgbGFyZ2UgbWFyZ2luXHJcbiAgICBpZiAocGxheWVyU2NvcmUgPCBvcHBvbmVudFNjb3JlIC0gMTApIHJldHVybiBcIkxPU1NcIjsgLy8gTG9zcyBieSBsYXJnZSBtYXJnaW5cclxuICAgIHJldHVybiBcIkRSQVdcIjsgLy8gQ2xvc2UgYmF0dGxlIGlzIGEgZHJhd1xyXG59OyJdLCJuYW1lcyI6WyJnZXRNYXJrZXRTZWVkIiwiZm9jdXMiLCJnZW5lcmF0ZVBlcmZvcm1hbmNlU2NvcmUiLCJjb25maWciLCJtYXJrZXRTZWVkIiwicmlza05vcm0iLCJyaXNrTGV2ZWwiLCJmcmVxdWVuY3lOb3JtIiwidHJhZGVGcmVxdWVuY3kiLCJzY29yZSIsImFsaWdubWVudCIsIk1hdGgiLCJhYnMiLCJtaW4iLCJtYXgiLCJyb3VuZCIsInJ1bkJhdHRsZVNpbXVsYXRpb24iLCJwbGF5ZXJDb25maWciLCJhc3NldEZvY3VzIiwicmFuZG9tRmFjdG9yIiwicmFuZG9tIiwiZmluYWxTY29yZSIsIm1vY2tPcHBvbmVudENvbmZpZyIsImdldFJlc3VsdCIsInBsYXllclNjb3JlIiwib3Bwb25lbnRTY29yZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/engine.ts\n"));

/***/ })

});