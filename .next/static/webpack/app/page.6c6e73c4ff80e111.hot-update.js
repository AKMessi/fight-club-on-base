"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/engine.ts":
/*!***********************!*\
  !*** ./lib/engine.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getResult: function() { return /* binding */ getResult; },\n/* harmony export */   mockOpponentConfig: function() { return /* binding */ mockOpponentConfig; },\n/* harmony export */   runBattleSimulation: function() { return /* binding */ runBattleSimulation; }\n/* harmony export */ });\n// @/lib/engine.ts\n// --- Core Types ---\n// --- Simulation Logic ---\n// Determines the market volatility seed based on the asset focus\nconst getMarketSeed = (focus)=>{\n    switch(focus){\n        case \"BlueChip\":\n            return 0.2; // Low Volatility\n        case \"Layer2\":\n            return 0.5; // Medium Volatility\n        case \"Memecoin\":\n            return 0.9; // High Volatility\n    }\n};\n// Generates a deterministic performance score (0 to 100)\n// Simplified logic: High risk pays off in high volatility (Memecoin), low risk pays off in low volatility (BlueChip)\nconst generatePerformanceScore = (config, marketSeed)=>{\n    // Normalize variables to 0-1\n    const riskNorm = config.riskLevel / 100;\n    const frequencyNorm = config.tradeFrequency / 100;\n    // Score calculation:\n    // 1. Base Score: A simple weighted average of risk and frequency (50/50 split)\n    let score = riskNorm * 0.5 + frequencyNorm * 0.5;\n    // 2. Volatility Alignment Bonus/Penalty:\n    //    - If Market Seed (volatility) is high (Memecoin), high risk gets a bonus.\n    //    - If Market Seed (volatility) is low (BlueChip), low risk gets a bonus.\n    const alignment = Math.abs(marketSeed - riskNorm);\n    // Apply a penalty based on misalignment (The smaller the alignment, the better the performance)\n    score = score + (1 - alignment) * 0.5;\n    // Scale the score back to 0-100 range and clamp\n    return Math.min(100, Math.max(0, Math.round(score * 100)));\n};\n// --- Battle Simulation Function ---\n// Returns a single number representing the final wealth score\nconst runBattleSimulation = (playerConfig)=>{\n    const marketSeed = getMarketSeed(playerConfig.assetFocus);\n    const score = generatePerformanceScore(playerConfig, marketSeed);\n    // Add a random element for drama, but keep it constrained (e.g., +/- 10%)\n    const randomFactor = Math.random() * 0.2 - 0.1; // -10% to +10%\n    const finalScore = score * (1 + randomFactor);\n    return Math.round(Math.min(100, Math.max(0, finalScore)));\n};\n// Simple mock opponent for comparison\nconst mockOpponentConfig = {\n    riskLevel: 45,\n    tradeFrequency: 55,\n    assetFocus: \"Layer2\"\n};\nconst getResult = (playerScore, opponentScore)=>{\n    if (playerScore > opponentScore + 10) return \"WIN\"; // Win by large margin\n    if (playerScore < opponentScore - 10) return \"LOSS\"; // Loss by large margin\n    return \"DRAW\"; // Close battle is a draw\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9lbmdpbmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsa0JBQWtCO0FBRWxCLHFCQUFxQjtBQVdyQiwyQkFBMkI7QUFFM0IsaUVBQWlFO0FBQ2pFLE1BQU1BLGdCQUFnQixDQUFDQztJQUNyQixPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPLEtBQUssaUJBQWlCO1FBQy9CLEtBQUs7WUFDSCxPQUFPLEtBQUssb0JBQW9CO1FBQ2xDLEtBQUs7WUFDSCxPQUFPLEtBQUssa0JBQWtCO0lBQ2xDO0FBQ0Y7QUFFQSx5REFBeUQ7QUFDekQscUhBQXFIO0FBQ3JILE1BQU1DLDJCQUEyQixDQUFDQyxRQUFtQkM7SUFDbkQsNkJBQTZCO0lBQzdCLE1BQU1DLFdBQVdGLE9BQU9HLFNBQVMsR0FBRztJQUNwQyxNQUFNQyxnQkFBZ0JKLE9BQU9LLGNBQWMsR0FBRztJQUU5QyxxQkFBcUI7SUFDckIsK0VBQStFO0lBQy9FLElBQUlDLFFBQVNKLFdBQVcsTUFBTUUsZ0JBQWdCO0lBRTlDLHlDQUF5QztJQUN6QywrRUFBK0U7SUFDL0UsNkVBQTZFO0lBQzdFLE1BQU1HLFlBQVlDLEtBQUtDLEdBQUcsQ0FBQ1IsYUFBYUM7SUFFeEMsZ0dBQWdHO0lBQ2hHSSxRQUFRQSxRQUFRLENBQUMsSUFBSUMsU0FBUSxJQUFLO0lBRWxDLGdEQUFnRDtJQUNoRCxPQUFPQyxLQUFLRSxHQUFHLENBQUMsS0FBS0YsS0FBS0csR0FBRyxDQUFDLEdBQUdILEtBQUtJLEtBQUssQ0FBQ04sUUFBUTtBQUN0RDtBQUVBLHFDQUFxQztBQUVyQyw4REFBOEQ7QUFDdkQsTUFBTU8sc0JBQXNCLENBQUNDO0lBQ2hDLE1BQU1iLGFBQWFKLGNBQWNpQixhQUFhQyxVQUFVO0lBQ3hELE1BQU1ULFFBQVFQLHlCQUF5QmUsY0FBY2I7SUFFckQsMEVBQTBFO0lBQzFFLE1BQU1lLGVBQWUsS0FBTUMsTUFBTSxLQUFLLE1BQU8sS0FBSyxlQUFlO0lBQ2pFLE1BQU1DLGFBQWFaLFFBQVMsS0FBSVUsWUFBVztJQUUzQyxPQUFPUixLQUFLSSxLQUFLLENBQUNKLEtBQUtFLEdBQUcsQ0FBQyxLQUFLRixLQUFLRyxHQUFHLENBQUMsR0FBR087QUFDaEQsRUFBRTtBQUVGLHNDQUFzQztBQUMvQixNQUFNQyxxQkFBZ0M7SUFDekNoQixXQUFXO0lBQ1hFLGdCQUFnQjtJQUNoQlUsWUFBWTtBQUNoQixFQUFFO0FBRUssTUFBTUssWUFBWSxDQUFDQyxhQUFxQkM7SUFDM0MsSUFBSUQsY0FBY0MsZ0JBQWdCLElBQUksT0FBTyxPQUFPLHNCQUFzQjtJQUMxRSxJQUFJRCxjQUFjQyxnQkFBZ0IsSUFBSSxPQUFPLFFBQVEsdUJBQXVCO0lBQzVFLE9BQU8sUUFBUSx5QkFBeUI7QUFDNUMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZW5naW5lLnRzP2YxNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQC9saWIvZW5naW5lLnRzXHJcblxyXG4vLyAtLS0gQ29yZSBUeXBlcyAtLS1cclxuZXhwb3J0IHR5cGUgQXNzZXRGb2N1cyA9IFwiQmx1ZUNoaXBcIiB8IFwiTGF5ZXIyXCIgfCBcIk1lbWVjb2luXCI7XHJcblxyXG5leHBvcnQgdHlwZSBCb3RDb25maWcgPSB7XHJcbiAgcmlza0xldmVsOiBudW1iZXI7IC8vIDEgdG8gMTAwXHJcbiAgdHJhZGVGcmVxdWVuY3k6IG51bWJlcjsgLy8gMSB0byAxMDBcclxuICBhc3NldEZvY3VzOiBBc3NldEZvY3VzO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgQmF0dGxlUmVzdWx0ID0gXCJXSU5cIiB8IFwiTE9TU1wiIHwgXCJEUkFXXCI7XHJcblxyXG4vLyAtLS0gU2ltdWxhdGlvbiBMb2dpYyAtLS1cclxuXHJcbi8vIERldGVybWluZXMgdGhlIG1hcmtldCB2b2xhdGlsaXR5IHNlZWQgYmFzZWQgb24gdGhlIGFzc2V0IGZvY3VzXHJcbmNvbnN0IGdldE1hcmtldFNlZWQgPSAoZm9jdXM6IEFzc2V0Rm9jdXMpOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAoZm9jdXMpIHtcclxuICAgIGNhc2UgXCJCbHVlQ2hpcFwiOlxyXG4gICAgICByZXR1cm4gMC4yOyAvLyBMb3cgVm9sYXRpbGl0eVxyXG4gICAgY2FzZSBcIkxheWVyMlwiOlxyXG4gICAgICByZXR1cm4gMC41OyAvLyBNZWRpdW0gVm9sYXRpbGl0eVxyXG4gICAgY2FzZSBcIk1lbWVjb2luXCI6XHJcbiAgICAgIHJldHVybiAwLjk7IC8vIEhpZ2ggVm9sYXRpbGl0eVxyXG4gIH1cclxufTtcclxuXHJcbi8vIEdlbmVyYXRlcyBhIGRldGVybWluaXN0aWMgcGVyZm9ybWFuY2Ugc2NvcmUgKDAgdG8gMTAwKVxyXG4vLyBTaW1wbGlmaWVkIGxvZ2ljOiBIaWdoIHJpc2sgcGF5cyBvZmYgaW4gaGlnaCB2b2xhdGlsaXR5IChNZW1lY29pbiksIGxvdyByaXNrIHBheXMgb2ZmIGluIGxvdyB2b2xhdGlsaXR5IChCbHVlQ2hpcClcclxuY29uc3QgZ2VuZXJhdGVQZXJmb3JtYW5jZVNjb3JlID0gKGNvbmZpZzogQm90Q29uZmlnLCBtYXJrZXRTZWVkOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gIC8vIE5vcm1hbGl6ZSB2YXJpYWJsZXMgdG8gMC0xXHJcbiAgY29uc3Qgcmlza05vcm0gPSBjb25maWcucmlza0xldmVsIC8gMTAwO1xyXG4gIGNvbnN0IGZyZXF1ZW5jeU5vcm0gPSBjb25maWcudHJhZGVGcmVxdWVuY3kgLyAxMDA7XHJcblxyXG4gIC8vIFNjb3JlIGNhbGN1bGF0aW9uOlxyXG4gIC8vIDEuIEJhc2UgU2NvcmU6IEEgc2ltcGxlIHdlaWdodGVkIGF2ZXJhZ2Ugb2YgcmlzayBhbmQgZnJlcXVlbmN5ICg1MC81MCBzcGxpdClcclxuICBsZXQgc2NvcmUgPSAocmlza05vcm0gKiAwLjUgKyBmcmVxdWVuY3lOb3JtICogMC41KTtcclxuXHJcbiAgLy8gMi4gVm9sYXRpbGl0eSBBbGlnbm1lbnQgQm9udXMvUGVuYWx0eTpcclxuICAvLyAgICAtIElmIE1hcmtldCBTZWVkICh2b2xhdGlsaXR5KSBpcyBoaWdoIChNZW1lY29pbiksIGhpZ2ggcmlzayBnZXRzIGEgYm9udXMuXHJcbiAgLy8gICAgLSBJZiBNYXJrZXQgU2VlZCAodm9sYXRpbGl0eSkgaXMgbG93IChCbHVlQ2hpcCksIGxvdyByaXNrIGdldHMgYSBib251cy5cclxuICBjb25zdCBhbGlnbm1lbnQgPSBNYXRoLmFicyhtYXJrZXRTZWVkIC0gcmlza05vcm0pO1xyXG4gIFxyXG4gIC8vIEFwcGx5IGEgcGVuYWx0eSBiYXNlZCBvbiBtaXNhbGlnbm1lbnQgKFRoZSBzbWFsbGVyIHRoZSBhbGlnbm1lbnQsIHRoZSBiZXR0ZXIgdGhlIHBlcmZvcm1hbmNlKVxyXG4gIHNjb3JlID0gc2NvcmUgKyAoMSAtIGFsaWdubWVudCkgKiAwLjU7IFxyXG4gIFxyXG4gIC8vIFNjYWxlIHRoZSBzY29yZSBiYWNrIHRvIDAtMTAwIHJhbmdlIGFuZCBjbGFtcFxyXG4gIHJldHVybiBNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoc2NvcmUgKiAxMDApKSk7XHJcbn07XHJcblxyXG4vLyAtLS0gQmF0dGxlIFNpbXVsYXRpb24gRnVuY3Rpb24gLS0tXHJcblxyXG4vLyBSZXR1cm5zIGEgc2luZ2xlIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGZpbmFsIHdlYWx0aCBzY29yZVxyXG5leHBvcnQgY29uc3QgcnVuQmF0dGxlU2ltdWxhdGlvbiA9IChwbGF5ZXJDb25maWc6IEJvdENvbmZpZyk6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCBtYXJrZXRTZWVkID0gZ2V0TWFya2V0U2VlZChwbGF5ZXJDb25maWcuYXNzZXRGb2N1cyk7XHJcbiAgICBjb25zdCBzY29yZSA9IGdlbmVyYXRlUGVyZm9ybWFuY2VTY29yZShwbGF5ZXJDb25maWcsIG1hcmtldFNlZWQpO1xyXG5cclxuICAgIC8vIEFkZCBhIHJhbmRvbSBlbGVtZW50IGZvciBkcmFtYSwgYnV0IGtlZXAgaXQgY29uc3RyYWluZWQgKGUuZy4sICsvLSAxMCUpXHJcbiAgICBjb25zdCByYW5kb21GYWN0b3IgPSAoTWF0aC5yYW5kb20oKSAqIDAuMikgLSAwLjE7IC8vIC0xMCUgdG8gKzEwJVxyXG4gICAgY29uc3QgZmluYWxTY29yZSA9IHNjb3JlICogKDEgKyByYW5kb21GYWN0b3IpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1pbigxMDAsIE1hdGgubWF4KDAsIGZpbmFsU2NvcmUpKSk7XHJcbn07XHJcblxyXG4vLyBTaW1wbGUgbW9jayBvcHBvbmVudCBmb3IgY29tcGFyaXNvblxyXG5leHBvcnQgY29uc3QgbW9ja09wcG9uZW50Q29uZmlnOiBCb3RDb25maWcgPSB7XHJcbiAgICByaXNrTGV2ZWw6IDQ1LFxyXG4gICAgdHJhZGVGcmVxdWVuY3k6IDU1LFxyXG4gICAgYXNzZXRGb2N1czogXCJMYXllcjJcIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRSZXN1bHQgPSAocGxheWVyU2NvcmU6IG51bWJlciwgb3Bwb25lbnRTY29yZTogbnVtYmVyKTogQmF0dGxlUmVzdWx0ID0+IHtcclxuICAgIGlmIChwbGF5ZXJTY29yZSA+IG9wcG9uZW50U2NvcmUgKyAxMCkgcmV0dXJuIFwiV0lOXCI7IC8vIFdpbiBieSBsYXJnZSBtYXJnaW5cclxuICAgIGlmIChwbGF5ZXJTY29yZSA8IG9wcG9uZW50U2NvcmUgLSAxMCkgcmV0dXJuIFwiTE9TU1wiOyAvLyBMb3NzIGJ5IGxhcmdlIG1hcmdpblxyXG4gICAgcmV0dXJuIFwiRFJBV1wiOyAvLyBDbG9zZSBiYXR0bGUgaXMgYSBkcmF3XHJcbn07Il0sIm5hbWVzIjpbImdldE1hcmtldFNlZWQiLCJmb2N1cyIsImdlbmVyYXRlUGVyZm9ybWFuY2VTY29yZSIsImNvbmZpZyIsIm1hcmtldFNlZWQiLCJyaXNrTm9ybSIsInJpc2tMZXZlbCIsImZyZXF1ZW5jeU5vcm0iLCJ0cmFkZUZyZXF1ZW5jeSIsInNjb3JlIiwiYWxpZ25tZW50IiwiTWF0aCIsImFicyIsIm1pbiIsIm1heCIsInJvdW5kIiwicnVuQmF0dGxlU2ltdWxhdGlvbiIsInBsYXllckNvbmZpZyIsImFzc2V0Rm9jdXMiLCJyYW5kb21GYWN0b3IiLCJyYW5kb20iLCJmaW5hbFNjb3JlIiwibW9ja09wcG9uZW50Q29uZmlnIiwiZ2V0UmVzdWx0IiwicGxheWVyU2NvcmUiLCJvcHBvbmVudFNjb3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/engine.ts\n"));

/***/ })

});